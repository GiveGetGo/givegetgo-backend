name: GiveGetGo CD Workflow for Development

on:
  push:
    branches:
      - development

jobs:
  # Build and push Docker images to ECR
  deploy-images-ecr:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/development'
    env:
      ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
      NGINX_REPO_NAME: ${{ secrets.AWS_ECR_NGINX_REPO }}
      GIVEGETGO_REPO_NAME: ${{ secrets.AWS_ECR_GIVEGETGO_REPO }}
    steps:
      # Checkout the repository
      - name: Checkout
        uses: actions/checkout@v4
      
      # Generate image tag
      - name: Generate iamge tag
        run: |
          echo "IMAGE_TAG=$(echo $GITHUB_SHA | cut -c1-7)-$(date +%Y%m%d%H%M)" >> $GITHUB_ENV

      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Login to AWS ECR service
      - name: Login to AWS ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Determine which services have changed
      # - name: Check for changed services
      #   id: changed_services
      #   run: |
      #     echo "::set-output name=user_service_changed::$(git diff --name-only ${{ github.sha }} ${{ github.event.before }} | grep -q 'servers/user' && echo 'true' || echo 'false')"
      #     echo "::set-output name=verification_service_changed::$(git diff --name-only ${{ github.sha }} ${{ github.event.before }} | grep -q 'servers/verification' && echo 'true' || echo 'false')"

      - name: Generate environment files for Docker Compose
        run: |
          echo "${{ secrets.REDIS_ENV }}" | base64 -d > "./redis/.env.redis"

          services=("user" "verification" "post" "bid" "match")
          for service in "${services[@]}"; do
            service_env_var_name="${service^^}_SERVICE_ENV"
            service_secret="${!service_env_var_name}"
        
            # Decode the environment variable and write to a file
            echo "$service_secret" | base64 -d > "./servers/$service/.env.$service"
          done
        env:
          USER_SERVICE_ENV: ${{ secrets.USER_SERVICE_ENV }}
          VERIFICATION_SERVICE_ENV: ${{ secrets.VERIFICATION_SERVICE_ENV }}
          POST_SERVICE_ENV: ${{ secrets.POST_SERVICE_ENV }}
          BID_SERVICE_ENV: ${{ secrets.BID_SERVICE_ENV }}
          MATCH_SERVICE_ENV: ${{ secrets.MATCH_SERVICE_ENV }}
            
      # Build and push Docker images
      - name: Build and push Docker images
        run: |
          declare -a services=("nginx" "user" "verification" "post" "bid" "match" "redis")

          for service in "${services[@]}"; do
            if [ "$service" == "nginx" ]; then
              image_tag="dev-nginx-$IMAGE_TAG"
              path="./nginx"
              repo_name=$NGINX_REPO_NAME
            elif [ "$service" == "redis" ]; then
              image_tag="dev-redis-$IMAGE_TAG"
              path="./redis"
              repo_name=$GIVEGETGO_REPO_NAME
            else
              image_tag="dev-${service}-$IMAGE_TAG"
              path="./servers/$service"
              repo_name=$GIVEGETGO_REPO_NAME
            fi

            docker build -t $ECR_REGISTRY/$repo_name:$image_tag $path
            docker push $ECR_REGISTRY/$repo_name:$image_tag
          done
        shell: bash

      # Update EKS kube config
      - name: Update EKS config
        run: |
          aws eks --region ${{ secrets.AWS_REGION }} update-kubeconfig --name ${{ secrets.AWS_EKS_CLUSTER_NAME }}

  # Create Kubernetes secrets for all services
  create-eks-secrets:
    runs-on: ubuntu-latest
    needs: deploy-images-ecr
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Update EKS config
        run: |
          aws eks --region ${{ secrets.AWS_REGION }} update-kubeconfig --name ${{ secrets.AWS_EKS_CLUSTER_NAME }}

      - name: Decode and create secrets for all services and their PostgreSQL
        env:
          USER_POSTGRES_ENV: ${{ secrets.USER_POSTGRES_ENV }}
          VERIFICATION_POSTGRES_ENV: ${{ secrets.VERIFICATION_POSTGRES_ENV }}
          POST_POSTGRES_ENV: ${{ secrets.POST_POSTGRES_ENV }}
          BID_POSTGRES_ENV: ${{ secrets.BID_POSTGRES_ENV }}
          MATCH_POSTGRES_ENV: ${{ secrets.MATCH_POSTGRES_ENV }}
        run: |
          services=("user" "verification" "post" "bid" "match")
          for service in "${services[@]}"; do
            # Construct the name of the environment variable
            postgres_env_var_name="${service^^}_POSTGRES_ENV"
      
            # Use the variable names to retrieve the secret values directly from the environment
            postgres_secret=$(printenv $postgres_env_var_name)
      
            # Decode the environment variable and write to a file
            echo "$postgres_secret" | base64 -d > "./$service-postgres.env"
      
            # Create Kubernetes secrets
            kubectl create secret generic ${service}-postgres-secrets --from-env-file=./$service-postgres.env --namespace givegetgo-development
          done
        shell: bash
                
  # Update ArgoCD applications with new image repo and tag
  update-argocd:
    runs-on: ubuntu-latest
    needs: deploy-images-ecr
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Install ArgoCD CLI
      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64 

      # Patch ArgoCD application to deploy the latest images
      - name: Patch ArgoCD application
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} --username ${{ secrets.ARGOCD_ADMIN }} --password ${{ secrets.ARGOCD_PASSWORD }} --insecure

      # Update ArgoCD applications with new image repo and tag
      - name: Update ArgoCD applications with new image repo and tag
        run: |
          argocd app set nginx \
            --helm-set images.repo="$ECR_REGISTRY/$NGINX_REPO_NAME" \
            --helm-set images.tag="dev-nginx-$IMAGE_TAG"

          for service in user verification post bid match redis; do
            # Construct the image repo and tag for the service
            APP_NAME="dev-givegetgo-backend-$service"
            IMAGE_REPO="$ECR_REGISTRY/$GIVEGETGO_REPO_NAME"
            IMAGE_TAG="${service}-$IMAGE_TAG"

            # Update the application in Argo CD
            argocd app set $APP_NAME \
              --helm-set images.repo="$IMAGE_REPO" \
              --helm-set images.tag="$IMAGE_TAG"
          done
      
          # Assuming user-postgres, post-postgres, etc., follow a naming convention
          for service in user-postgres post-postgres verification-postgres bid-postgres match-postgres; do
            # Construct the image repo and tag for Postgres, assuming they are different
            PG_IMAGE_REPO"$ECR_REGISTRY/$GIVEGETGO_REPO_NAME"
            PG_IMAGE_TAG="${service}-$IMAGE_TAG"
      
            # Update the application in Argo CD
            argocd app set "dev-givegetgo-$service" \
              --helm-set images.repo="$PG_IMAGE_REPO" \
              --helm-set images.tag="$PG_IMAGE_TAG"
          done
        shell: bash
